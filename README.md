# Quick-Sort（快速排序）
通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序。
整个排序过程可以递归进行，以此达到整个数据变成有序序列。

## Solution
分治法

## 复杂度分析
最好情况：时间复杂度为O(NlogN)；  
最坏情况：时间复杂度为O(N*N)；  
平均性能：时间复杂度为O(NlogN)。  

快速排序的时间主要耗费在划分操作上，对长度为k的区间进行划分，共需k-1次关键字的比较；
最坏情况下，每次划分选取的基准都是当前无序区中关键字最小(或最大)的记录，划分的结果是基准左边的子区间为空(或右边的子区间为空)，而划分所得的另一个非空的子区间中记录数目，仅仅比划分前的无序区中记录个数减少一个。时间复杂度为O(N*N)；
最好情况下，每次划分所取的基准都是当前无序区的"中值"记录，划分的结果是基准的左、右两个无序子区间的长度大致相等。总的关键字比较次数为O(NlogN)；
但就平均性能而言，它是基于关键字比较的内部排序算法中速度最快者，快速排序亦因此而得名。

## Sample
假设一开始序列{xi}是：5，3，7，6，4，1，0，2，9，10，8。  
此时，ref=5，i=1，j=11，从后往前找，第一个比5小的数是x8=2，因此序列为：2，3，7，6，4，1，0，5，9，10，8；    
此时，i=1，j=8，从前往后找，第一个比5大的数是x3=7，因此序列为：2，3，5，6，4，1，0，7，9，10，8；  
此时，i=3，j=8，从第8位往前找，第一个比5小的数是x7=0，因此：2，3，0，6，4，1，5，7，9，10，8；  
此时，i=3，j=7，从第3位往后找，第一个比5大的数是x4=6，因此：2，3，0，5，4，1，6，7，9，10，8；  
此时，i=4，j=7，从第7位往前找，第一个比5小的数是x6=1，因此：2，3，0，1，4，5，6，7，9，10，8；  
此时，i=4，j=6，从第4位往后找，直到第6位才有比5大的数；  
这时，i=j=6，ref成为一条分界线，它之前的数都比它小，之后的数都比它大，对于前后两部分数，可以采用同样的方法来排序。
